package koopa.core.data;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import koopa.core.targets.HoldingTarget;

/**
 * This is the main data item generated by Koopa.
 *
 * They represent pieces of text, and can carry some metadata in the form of tags.
 * <p>
 * Tags themselves can be anything; though we recommend using enums.
 * <p>
 * <b>Trying to keep this class immutable.</b>
 */
public class Token implements Data {

    private final String text;

    /**
     * Which {@linkplain Range}s make up this token?
     * <p>
     * <b>Unmodifiable, and always based on a copy of any provided list of ranges !</b>
     */
    private final List<Range> ranges;

    /**
     * Which tags does this token carry?
     * <p>
     * <b>Unmodifiable !</b>
     */
    private final Set<Object> tags;

    private final Replaced replaced;

    /**
     * Was this token skipped during the parse, or not?
     * <p>
     * <b>This is a mutable field in an immutable class</b>;
     * which, of course, is not what you want, but I made this field mutable for performance reasons.
     * The preferred way was to add this info as another tag,
     * but this was one piece of information which was added and retracted
     * so often that it imposed too much of a performance penalty on the runtime
     * (adding about 30% of time to parsing the testsuite).
     * <p>
     * Alternate solutions considered:
     * <ul>
     * <li>Markers, such as for water. But there would be way too many of these as well.</li>
     * <li>Asking the grammar. But that only tells you whether a token can be skipped,
     *     not whether it actually was in the end. Removing the ambiguity is not an option for Cobol.</li>
     * <li>Counting schemes, or separate bookkeeping, in {@linkplain HoldingTarget}.
     *     Felt too complex and cumbersome.</li>
     * </ul>
     */
    private boolean skipped = false;

    /**
     * Creates a new token from the given text, boundaries and tags.
     * <p>
     * Start and end positions should belong to the same resource.
     * I.e. <code>start.getResourceName()</code> and
     * <code>(end.getResourceName())</code> are both null, or are equal.
     */
    public Token(String text, Position start, Position end, Object... tags) {
        assert (start != null);
        assert (end != null);
        assert (start.getResourceName() == null && end.getResourceName() == null
                || start.getResourceName() != null && start.getResourceName().equals(end.getResourceName()));

        this.text = text;

        final var ranges = new ArrayList<Range>(1);
        ranges.add(new Range(start, end));

        this.ranges = Collections.unmodifiableList(ranges);
        this.tags = Collections.unmodifiableSet(new HashSet<Object>(Arrays.asList(tags)));

        this.replaced = null;
    }

    /**
     * <b>NOTE</b> This is package scoped on purpose.
     * Intended for use by {@linkplain Tokens} only.
     */
    Token(String text, List<Range> ranges, Set<Object> tags, Replaced replacing) {
        assert (ranges != null);
        assert (ranges.size() > 0);

        this.text = text;

        final var rangesCopy = new ArrayList<Range>();
        rangesCopy.addAll(ranges);

        this.ranges = Collections.unmodifiableList(rangesCopy);
        this.tags = Collections.unmodifiableSet(tags);

        this.replaced = replacing;
    }

    /**
     * Creates a new token which is equivalent to the composition of the given ones, except for their tags.
     * <p>
     * <b>The tags of the original tokens are not aggregated.</b>
     * Instead you can specify whatever tags the new token should have as extra parameters.
     * <p>
     * The {@linkplain Range}s of the original tokens, however, do get aggregated into the new one.
     * <p>
     * The new token will not be seen as replacing some other token, despite what any of the given tokens may say.
     * <p>
     * <b>NOTE</b> This is package scoped on purpose.
     * Please use the {@linkplain Tokens#join(List, Object...)} method instead.
     */
    Token(List<Token> tokens, Object... tags) {
        var buffer = new StringBuilder();

        for (var token : tokens) {
            buffer.append(token.getText());
        }
        this.text = buffer.toString();

        final var list = new ArrayList<Range>();
        for (var token : tokens) {
            list.addAll(token.ranges);
        }
        assert (list.size() > 0);

        this.ranges = Collections.unmodifiableList(list);
        this.tags = Collections.unmodifiableSet(new HashSet<Object>(Arrays.asList(tags)));
        this.replaced = null;
    }

    /**
     * Create a copy of one token, and register the copy as being a replacement for another one.
     */
    private Token(Token token, Replaced replacing) {
        assert (token != null);
        assert (replacing != null);
        this.text = token.text;
        this.ranges = token.ranges;
        this.tags = token.tags;
        this.replaced = replacing;
    }

    public String getText() {
        return this.text;
    }

    public char charAt(int index) {
        return text.charAt(index);
    }

    public int getLength() {
        return text.length();
    }

    public Position getStart() {
        return ranges.get(0).getStart();
    }

    public Position getEnd() {
        return ranges.get(ranges.size() - 1).getEnd();
    }

    public Set<Object> getTags() {
        return tags;
    }

    public boolean hasTag(Object tag) {
        return tags.contains(tag);
    }

    /**
     * Whether or not this token has <b>all</b> given tags.
     */
    public boolean hasTags(Object... tags) {
        for (var tag : tags) {
            if (!hasTag(tag)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Whether or not this token has <b>any</b> of the given tags.
     */
    public boolean hasAnyTag(Object... tags) {
        for (var tag : tags) {
            if (hasTag(tag)) {
                return true;
            }
        }
        return false;
    }

    public int tagCount() {
        return tags.size();
    }

    public List<Range> getRanges() {
        return ranges;
    }

    /**
     * Creates a new token which is a copy of this one, with the addition of the
     * given tags. If there are no tags given, or they are all already there,
     * returns <code>this</code> instead.
     */
    public Token withTags(Object... additionalTags) {
        if (additionalTags.length == 0) {
            return this;
        }
        if (hasTags(additionalTags)) {
            return this;
        }
        var newTags = new HashSet<Object>(tags);
        newTags.addAll(Arrays.asList(additionalTags));
        return new Token(text, ranges, newTags, replaced);
    }

    /**
     * Creates a new token which is a copy of this one, with the exception of
     * the given tags. If there are no tags given, or none of them are found
     * here, returns <code>this</code> instead.
     */
    public Token withoutTags(Object... theseTags) {
        if (theseTags.length == 0) {
            return this;
        }
        if (!hasAnyTag(theseTags)) {
            return this;
        }
        var newTags = new HashSet<Object>(tags);
        newTags.removeAll(Arrays.asList(theseTags));
        return new Token(text, ranges, newTags, replaced);
    }

    /**
     * Creates a new token which is a copy of this one, minus one tag (if
     * present), and with the addition of the other.
     */
    public Token replacingTag(Object oldTag, Object newTag) {
        var newTags = new HashSet<Object>(tags);
        newTags.remove(oldTag);
        newTags.add(newTag);
        return new Token(text, ranges, newTags, replaced);
    }

    /**
     * Creates a copy of this token, while linking it to another one by saying
     * that this token replaces it, either completely or in part.
     */
    public Token asReplacing(Replaced replacing) {
        if (replacing == null) {
            return this;
        } else {
            return new Token(this, replacing);
        }
    }

    public Replaced getReplaced() {
        return replaced;
    }

    public boolean isReplacement() {
        return replaced != null;
    }

    @Override
    public String toString() {
        String s = null;
        if (replaced == null) {
            s = "[" + getStart() + "|" + text + "|" + getEnd() + "]";
        } else {
            s = "{" + getStart() + "|" + text + "|" + getEnd() + "}";
        }
        if (!tags.isEmpty()) {
            for (var tag : tags) {
                s += " @" + tag;
            }
        }
        return s;
    }

    public boolean isSkipped() {
        return skipped;
    }

    public void setSkipped(boolean skipped) {
        this.skipped = skipped;
    }

    private static int hashCounter = 0;
    private final int HASHCODE = hashCounter++;

    /**
     * For {@linkplain Token} instances, equality boils down to object identity.
     */
    @Override
    public boolean equals(Object obj) {
        return this == obj;
    }

    /**
     * Hashcodes for {@linkplain Token} objects are nothing more than a sequentially generated identifier.
     */
    @Override
    public int hashCode() {
        return HASHCODE;
    }

}
